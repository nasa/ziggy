package gov.nasa.ziggy.uow;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections4.CollectionUtils;

import gov.nasa.ziggy.collections.ZiggyDataType;
import gov.nasa.ziggy.data.datastore.DataFileType;
import gov.nasa.ziggy.data.datastore.DatastoreRegexp;
import gov.nasa.ziggy.data.datastore.DatastoreWalker;
import gov.nasa.ziggy.module.ExternalProcessPipelineModule;
import gov.nasa.ziggy.pipeline.definition.Parameter;
import gov.nasa.ziggy.pipeline.definition.PipelineInstanceNode;
import gov.nasa.ziggy.pipeline.definition.database.PipelineDefinitionNodeOperations;
import gov.nasa.ziggy.services.config.DirectoryProperties;
import gov.nasa.ziggy.util.AcceptableCatchBlock;
import gov.nasa.ziggy.util.AcceptableCatchBlock.Rationale;

/**
 * Subclass of {@link DirectoryUnitOfWorkGenerator} that selects units of work based on the
 * directory tree configuration of the datastore. This is the default unit of work for the
 * {@link ExternalProcessPipelineModule} class.
 * <p>
 * Each unit of work has a brief state generated by a {@link DatastoreWalker} instance. This implies
 * that, if the UOW has multiple input data file types, all the paths for a given UOW must
 * correspond to the same brief state.
 * <p>
 * The unit of work also captures the values of all {@link DatastoreRegexp} instances that were used
 * to construct the UOW.
 *
 * @author PT
 */
public class DatastoreDirectoryUnitOfWorkGenerator extends DirectoryUnitOfWorkGenerator {

    private static final String BRIEF_STATE_PART_SEPARATOR = ";";
    private static final String BRIEF_STATE_OPEN_STRING = "[";
    private static final String BRIEF_STATE_CLOSE_STRING = "]";
    private static final String SINGLE_UOW_BRIEF_STATE = "Single";

    private DatastoreWalker datastoreWalker;

    private PipelineDefinitionNodeOperations pipelineDefinitionNodeOperations = new PipelineDefinitionNodeOperations();

    @Override
    protected Path rootDirectory() {
        return DirectoryProperties.datastoreRootDir();
    }

    @Override
    public List<UnitOfWork> generateUnitsOfWork(PipelineInstanceNode pipelineInstanceNode) {
        Set<DataFileType> inputDataFileTypes = pipelineDefinitionNodeOperations()
            .inputDataFileTypes(pipelineInstanceNode.getPipelineDefinitionNode());
        if (CollectionUtils.isEmpty(inputDataFileTypes)) {
            throw new IllegalArgumentException("Pipeline definition has no input data file types");
        }

        // Construct a List of DataFileTypeInformation instances.
        List<DataFileTypeInformation> dataFileTypesInformation = dataFileTypesInformation(
            inputDataFileTypes);

        // If we didn't find any datastore paths that can be made into UOWs, exit now.
        if (dataFileTypesInformation.isEmpty()) {
            return new ArrayList<>();
        }

        // Rearrange the paths and brief states to a List of UowPathInformation instances.
        // This will give us one UowPathInformation instance per UOW.
        Collection<UowPathInformation> unitsOfWorkPathInformation = pathsForUnitOfWork(
            dataFileTypesInformation);

        // Generate the UOWs from the BriefStatePathInformation instances.
        List<UnitOfWork> unitsOfWork = new ArrayList<>();
        for (UowPathInformation unitOfWorkPathInformation : unitsOfWorkPathInformation) {
            UnitOfWork uow = new UnitOfWork(unitOfWorkPathInformation.getBriefState());

            // Populate the UOW parameters for the datastore paths used by this UOW.
            populateDirectoryParameters(uow, unitOfWorkPathInformation);

            // Populate the regular expression parameters used by this UOW.
            Map<String, String> uowRegexpValuesByName = uowRegexpValuesByName(
                unitOfWorkPathInformation);
            for (Map.Entry<String, String> regexpEntry : uowRegexpValuesByName.entrySet()) {
                uow.addParameter(new Parameter(regexpEntry.getKey(), regexpEntry.getValue(),
                    ZiggyDataType.ZIGGY_STRING));
            }
            unitsOfWork.add(uow);
        }
        return unitsOfWork;
    }

    /**
     * Constructs a {@link List} of {@link DataFileTypeInformation} instances. Each instance
     * contains one of the {@link DataFileType}s used for inputs and the brief state and
     * {@link Path} that correspond to that DataFileType. The returned List therefore contains all
     * of the Paths that will need to be used by the current pipeline module to find inputs, along
     * with the DataFileType and brief state that go with that path.
     * <p>
     * Note that, at this point, no attempt is made to organize the information by brief state.
     * Thus, the returned List will contain multiple entries for each brief state; specifically, one
     * entry per input data file type per brief state. This will later be rearranged into a Map that
     * is organized by brief state.
     */
    private List<DataFileTypeInformation> dataFileTypesInformation(
        Set<DataFileType> inputDataFileTypes) {
        List<DataFileTypeInformation> dataFileTypesInformation = new ArrayList<>();
        for (DataFileType inputType : inputDataFileTypes) {
            List<Path> uowPaths = datastoreWalker().pathsForLocation(inputType.getLocation());
            if (CollectionUtils.isEmpty(uowPaths)) {
                continue;
            }

            List<Integer> pathElementIndicesForBriefState = datastoreWalker()
                .pathElementIndicesForBriefState(uowPaths);

            // If there is only 1 UOW, it stands to reason that we can't identify any path
            // elements that vary from one UOW to another! In this special case, we use
            // all regexp values EXCEPT the ones specified in the location (i.e.,
            // if the location is "foo/bar$baz/blah", and all 3 elements are regexps, we
            // take only "foo" and "blah").
            if (CollectionUtils.isEmpty(pathElementIndicesForBriefState)) {
                dataFileTypesInformation.add(new DataFileTypeInformation(inputType,
                    briefStateFromAllRegexps(datastoreWalker()
                        .regexpValuesByRegexpName(inputType.getLocation(), uowPaths.get(0), false)),
                    uowPaths.get(0)));
            } else {
                for (Path uowPath : uowPaths) {
                    if (!Files.exists(uowPath) || !Files.isDirectory(uowPath)) {
                        continue;
                    }
                    DatastoreDirectoryBriefStateBuilder briefStateBuilder = new DatastoreDirectoryBriefStateBuilder();
                    for (int elementIndex : pathElementIndicesForBriefState) {
                        briefStateBuilder.addUowPart(uowPath.getName(elementIndex));
                    }
                    dataFileTypesInformation.add(
                        new DataFileTypeInformation(inputType, briefStateBuilder.build(), uowPath));
                }
            }
        }
        return dataFileTypesInformation;
    }

    /** Generates a brief state string from the values of all regular expressions. */
    private String briefStateFromAllRegexps(Map<String, String> regexpValues) {

        // A special case within a special case: we have no regular expressions at all!
        // In this case, the only thing we can do is issue a default brief state string.
        if (regexpValues.isEmpty()) {
            return singlePartBriefState();
        }
        DatastoreDirectoryBriefStateBuilder briefStateBuilder = new DatastoreDirectoryBriefStateBuilder();
        for (Map.Entry<String, String> regexpEntry : regexpValues.entrySet()) {
            briefStateBuilder.addUowPart(regexpEntry.getValue());
        }
        return briefStateBuilder.build();
    }

    /**
     * Generate {@link UowPathInformation}. Each {@link UowPathInformation} instance has a brief
     * state string and, for that brief state, a {@link Map} of paths by data file type. Thus, each
     * entry in the returned {@link List} represents a single unit of work and contains all the
     * datastore paths that will be needed to populate the inputs of the task for that unit of work.
     */
    private Collection<UowPathInformation> pathsForUnitOfWork(
        List<DataFileTypeInformation> dataFileTypesInformation) {

        Map<String, UowPathInformation> pathInfoByBriefState = new HashMap<>();

        // Construct the Map from all of the brief states.
        for (DataFileTypeInformation info : dataFileTypesInformation) {
            String briefState = info.getBriefState();
            if (pathInfoByBriefState.get(briefState) == null) {
                pathInfoByBriefState.put(briefState, new UowPathInformation(briefState));
            }
            pathInfoByBriefState.get(info.getBriefState())
                .addDataFileTypeAndPath(info.getDataFileType(), info.getDataFilePath());
        }

        return pathInfoByBriefState.values();
    }

    /** Generates a {@link Map} of regular expression values for a given unit of work. */
    private Map<String, String> uowRegexpValuesByName(UowPathInformation uowPathInformation) {

        Map<String, String> uowRegexpValuesByName = new HashMap<>();
        Set<String> regexpNamesToExclude = new HashSet<>();
        for (Map.Entry<DataFileType, Path> entry : uowPathInformation.getPathByDataFileType()
            .entrySet()) {

            Map<String, String> datastoreWalkerRegexpValues = datastoreWalker()
                .regexpValues(entry.getKey().getLocation(), entry.getValue());
            for (Map.Entry<String, String> regexpEntry : datastoreWalkerRegexpValues.entrySet()) {
                if (regexpNamesToExclude.contains(regexpEntry.getKey())) {
                    continue;
                }

                // Capture any regexp values we don't already have.
                if (uowRegexpValuesByName.get(regexpEntry.getKey()) == null) {
                    uowRegexpValuesByName.put(regexpEntry.getKey(), regexpEntry.getValue());
                }

                // If we have multiple input data file types, there may be regular expressions
                // that differ from one data file type to another. For example, if one data file
                // type has a location of "foo/bar$bar/blah" and another is "foo/bar$baz/blah", then
                // the two will agree on the "foo" and the "blah" but not the "bar/baz" in the
                // middle. Any regular expression that falls in
                if (!uowRegexpValuesByName.get(regexpEntry.getKey())
                    .equals(regexpEntry.getValue())) {
                    regexpNamesToExclude.add(regexpEntry.getKey());
                    uowRegexpValuesByName.remove(regexpEntry.getKey());
                }
            }
        }
        return uowRegexpValuesByName;
    }

    /** Add to a {@link UnitOfWork} instance the datastore directory paths for that UOW. */
    private void populateDirectoryParameters(UnitOfWork uow,
        UowPathInformation uowPathInformation) {
        for (Map.Entry<DataFileType, Path> entry : uowPathInformation.getPathByDataFileType()
            .entrySet()) {
            uow.addParameter(new Parameter(
                DIRECTORY_PARAMETER_NAME + DirectoryUnitOfWorkGenerator.DIRECTORY_NAME_SEPARATOR
                    + entry.getKey().getName(),
                entry.getValue().toString(), ZiggyDataType.ZIGGY_STRING));
        }
    }

    /** Extracts datastore regexp values from typed parameters and returns as a Map. */
    @AcceptableCatchBlock(rationale = Rationale.CAN_NEVER_OCCUR)
    public static Map<String, String> regexpValues(UnitOfWork uow) {
        String uowGenerator = uow.getParameter(GENERATOR_CLASS_PARAMETER_NAME).getString();
        Class<?> uowGeneratorClass;
        try {
            uowGeneratorClass = Class.forName(uowGenerator);
        } catch (ClassNotFoundException e) {
            // This can never occur, since Ziggy used the generator in question to construct
            // the UOW instance in the first place.
            throw new AssertionError(e);
        }
        if (!DatastoreDirectoryUnitOfWorkGenerator.class.isAssignableFrom(uowGeneratorClass)) {
            throw new IllegalArgumentException("Unit of work generator " + uowGenerator
                + " is not DatastoreDirectoryUnitOfWorkGenerator or a subclass of same");
        }
        Map<String, String> regexpValues = new HashMap<>();
        for (Parameter parameter : uow.getParameters()) {
            if (parameter.getName()
                .startsWith(DirectoryUnitOfWorkGenerator.DIRECTORY_PARAMETER_NAME)
                || parameter.getName().equals(UnitOfWork.BRIEF_STATE_PARAMETER_NAME)
                || parameter.getName().equals(GENERATOR_CLASS_PARAMETER_NAME)) {
                continue;
            }
            regexpValues.put(parameter.getName(), parameter.getString());
        }
        return regexpValues;
    }

    /**
     * The {@link setBriefState} method is empty because we set the brief state in the UOW
     * generator, above.
     */
    @Override
    public void setBriefState(UnitOfWork uow, PipelineInstanceNode pipelineInstanceNode) {
    }

    public DatastoreWalker datastoreWalker() {
        if (datastoreWalker == null) {
            datastoreWalker = DatastoreWalker.newInstance();
        }
        return datastoreWalker;
    }

    public PipelineDefinitionNodeOperations pipelineDefinitionNodeOperations() {
        return pipelineDefinitionNodeOperations;
    }

    /** Uses a fluent pattern to assemble a UOW brief state from Strings. */
    public static class DatastoreDirectoryBriefStateBuilder {

        private final List<String> uowParts = new ArrayList<>();

        public DatastoreDirectoryBriefStateBuilder() {
        }

        public DatastoreDirectoryBriefStateBuilder addUowPart(String uowPart) {
            uowParts.add(uowPart);
            return this;
        }

        public DatastoreDirectoryBriefStateBuilder addUowPart(Path path) {
            uowParts.add(path.getFileName().toString());
            return this;
        }

        public String build() {
            if (CollectionUtils.isEmpty(uowParts)) {
                return new String();
            }
            StringBuilder sb = new StringBuilder(BRIEF_STATE_OPEN_STRING);
            for (String uowPart : uowParts) {
                sb.append(uowPart);
                sb.append(BRIEF_STATE_PART_SEPARATOR);
            }
            sb.setLength(sb.length() - 1);
            sb.append(BRIEF_STATE_CLOSE_STRING);
            return sb.toString();
        }
    }

    public static String singlePartBriefState() {
        return new DatastoreDirectoryBriefStateBuilder().addUowPart(SINGLE_UOW_BRIEF_STATE).build();
    }

    /** Container for holding a data file type, a brief state, and a data path. */
    private static class DataFileTypeInformation {

        private final DataFileType dataFileType;
        private final String briefState;
        private final Path dataFilePath;

        public DataFileTypeInformation(DataFileType dataFileType, String briefState,
            Path dataFilePath) {
            this.dataFileType = dataFileType;
            this.briefState = briefState;
            this.dataFilePath = dataFilePath;
        }

        public DataFileType getDataFileType() {
            return dataFileType;
        }

        public String getBriefState() {
            return briefState;
        }

        private Path getDataFilePath() {
            return dataFilePath;
        }
    }

    /**
     * Container that holds the brief state and the {@link Map} of datastore paths by data file type
     * for a single unit of work.
     *
     * @author PT
     */
    private static class UowPathInformation {

        private final String briefState;
        private final Map<DataFileType, Path> pathByDataFileType = new HashMap<>();

        public UowPathInformation(String briefState) {
            this.briefState = briefState;
        }

        public String getBriefState() {
            return briefState;
        }

        public Map<DataFileType, Path> getPathByDataFileType() {
            return pathByDataFileType;
        }

        public void addDataFileTypeAndPath(DataFileType dataFileType, Path path) {
            pathByDataFileType.put(dataFileType, path);
        }
    }
}
